{"id":"node_modules/popmotion/transformers.js","dependencies":[{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/transformers.js.map","includedInParent":true,"mtime":1525955812000},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/src/transformers.ts","includedInParent":true,"mtime":1521824142000},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/package.json","includedInParent":true,"mtime":1611669448384},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/package.json","includedInParent":true,"mtime":1611669448356},{"name":"framesync","loc":{"line":11,"column":26},"parent":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/transformers.js","resolved":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/framesync/dist/framesync.es.js"},{"name":"style-value-types","loc":{"line":12,"column":34},"parent":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/transformers.js","resolved":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/style-value-types/dist/style-value-types.es.js"},{"name":"./calc","loc":{"line":13,"column":21},"parent":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/transformers.js","resolved":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/calc.js"}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar framesync_1 = require(\"framesync\");\nvar style_value_types_1 = require(\"style-value-types\");\nvar calc_1 = require(\"./calc\");\nvar noop = function (v) { return v; };\nexports.appendUnit = function (unit) { return function (v) { return \"\" + v + unit; }; };\nexports.applyOffset = function (from, to) {\n    var hasReceivedFrom = true;\n    if (to === undefined) {\n        to = from;\n        hasReceivedFrom = false;\n    }\n    var getOffset = function (v) { return v - from; };\n    var applyOffsetTo = function (v) { return v + to; };\n    return function (v) {\n        if (hasReceivedFrom) {\n            return applyOffsetTo(getOffset(v));\n        }\n        else {\n            from = v;\n            hasReceivedFrom = true;\n            return to;\n        }\n    };\n};\nvar blend = function (from, to, v) {\n    var fromExpo = from * from;\n    var toExpo = to * to;\n    return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);\n};\nexports.blendColor = function (from, to) {\n    var fromColor = (typeof from === 'string') ? style_value_types_1.color.parse(from) : from;\n    var toColor = (typeof to === 'string') ? style_value_types_1.color.parse(to) : to;\n    var blended = __assign({}, fromColor);\n    var blendFunc = (from.hue !== undefined ||\n        typeof from === 'string' && style_value_types_1.hsla.test(from)) ? calc_1.getValueFromProgress\n        : blend;\n    return function (v) {\n        blended = __assign({}, blended);\n        for (var key in blended) {\n            if (key !== 'alpha' && blended.hasOwnProperty(key)) {\n                blended[key] = blendFunc(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = calc_1.getValueFromProgress(fromColor.alpha, toColor.alpha, v);\n        return blended;\n    };\n};\nexports.clamp = function (min, max) { return function (v) { return Math.min(Math.max(v, min), max); }; };\nvar combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };\nexports.pipe = function () {\n    var transformers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        transformers[_i] = arguments[_i];\n    }\n    return transformers.reduce(combineFunctions);\n};\nexports.conditional = function (check, apply) { return function (v) { return check(v) ? apply(v) : v; }; };\nvar slowInterpolate = function (input, output, rangeLength, rangeEasing) {\n    var finalIndex = rangeLength - 1;\n    if (input[0] > input[finalIndex]) {\n        input.reverse();\n        output.reverse();\n    }\n    return function (v) {\n        if (v <= input[0]) {\n            return output[0];\n        }\n        if (v >= input[finalIndex]) {\n            return output[finalIndex];\n        }\n        var i = 1;\n        for (; i < rangeLength; i++) {\n            if (input[i] > v || i === finalIndex) {\n                break;\n            }\n        }\n        var progressInRange = calc_1.getProgressFromValue(input[i - 1], input[i], v);\n        var easedProgress = (rangeEasing) ? rangeEasing[i - 1](progressInRange) : progressInRange;\n        return calc_1.getValueFromProgress(output[i - 1], output[i], easedProgress);\n    };\n};\nvar fastInterpolate = function (minA, maxA, minB, maxB) { return function (v) {\n    return (((v - minA) * (maxB - minB)) / (maxA - minA)) + minB;\n}; };\nexports.interpolate = function (input, output, rangeEasing) {\n    var rangeLength = input.length;\n    return rangeLength !== 2\n        ? slowInterpolate(input, output, rangeLength, rangeEasing)\n        : fastInterpolate(input[0], input[1], output[0], output[1]);\n};\nexports.generateStaticSpring = function (alterDisplacement) {\n    if (alterDisplacement === void 0) { alterDisplacement = noop; }\n    return function (constant, origin) { return function (v) {\n        var displacement = origin - v;\n        var springModifiedDisplacement = -constant * (0 - alterDisplacement(Math.abs(displacement)));\n        return (displacement <= 0) ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n    }; };\n};\nexports.linearSpring = exports.generateStaticSpring();\nexports.nonlinearSpring = exports.generateStaticSpring(Math.sqrt);\nexports.wrap = function (min, max) { return function (v) {\n    var rangeSize = max - min;\n    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n}; };\nexports.smooth = function (strength) {\n    if (strength === void 0) { strength = 50; }\n    var previousValue = 0;\n    var lastUpdated = 0;\n    return function (v) {\n        var currentFramestamp = framesync_1.currentFrameTime();\n        var timeDelta = (currentFramestamp !== lastUpdated) ? currentFramestamp - lastUpdated : 0;\n        var newValue = timeDelta ? calc_1.smooth(v, previousValue, timeDelta, strength) : previousValue;\n        lastUpdated = currentFramestamp;\n        previousValue = newValue;\n        return newValue;\n    };\n};\nexports.snap = function (points) {\n    if (typeof points === 'number') {\n        return function (v) { return Math.round(v / points) * points; };\n    }\n    else {\n        var i_1 = 0;\n        var numPoints_1 = points.length;\n        return function (v) {\n            var lastDistance = Math.abs(points[0] - v);\n            for (i_1 = 1; i_1 < numPoints_1; i_1++) {\n                var point = points[i_1];\n                var distance = Math.abs(point - v);\n                if (distance === 0)\n                    return point;\n                if (distance > lastDistance)\n                    return points[i_1 - 1];\n                if (i_1 === numPoints_1 - 1)\n                    return point;\n                lastDistance = distance;\n            }\n        };\n    }\n};\nexports.steps = function (st, min, max) {\n    if (min === void 0) { min = 0; }\n    if (max === void 0) { max = 1; }\n    return function (v) {\n        var progress = calc_1.getProgressFromValue(min, max, v);\n        return calc_1.getValueFromProgress(min, max, calc_1.stepProgress(st, progress));\n    };\n};\nexports.transformMap = function (childTransformers) { return function (v) {\n    var output = __assign({}, v);\n    for (var key in childTransformers) {\n        if (childTransformers.hasOwnProperty(key)) {\n            var childTransformer = childTransformers[key];\n            output[key] = childTransformer(v[key]);\n        }\n    }\n    return output;\n}; };\n"},"sourceMaps":{"js":{"version":3,"file":"transformers.js","sourceRoot":"","sources":["src/transformers.ts"],"names":[],"mappings":"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","sourcesContent":["import { currentFrameTime } from 'framesync';\nimport { color, Color, hsla, HSLA } from 'style-value-types';\nimport { getProgressFromValue, getValueFromProgress, smooth as calcSmoothing, stepProgress } from './calc';\nimport { Easing } from './easing';\n\nconst noop = (v: any): any => v;\n\n/**\n * Append Unit\n * A function that will append\n * appendUnit('px', 20) -> '20px'\n * @param  {string} unit)\n * @return {number}\n */\nexport const appendUnit = (unit: string) => (v: number) => `${v}${unit}`;\n\n/**\n * Apply offset\n * A function that, given a value, will get the offset from `from`\n * and apply it to `to`\n * @param  {number} from\n * @param  {number} to\n * @return {function}\n */\nexport const applyOffset = (from: number, to?: number) => {\n  let hasReceivedFrom = true;\n  if (to === undefined) {\n    to = from;\n    hasReceivedFrom = false;\n  }\n\n  const getOffset = (v: number) => v - from;\n  const applyOffsetTo = (v: number) => v + to;\n  return (v: number) => {\n    if (hasReceivedFrom) {\n      return applyOffsetTo(getOffset(v));\n    } else {\n      from = v;\n      hasReceivedFrom = true;\n      return to;\n    }\n  };\n};\n\nconst blend = (from: number, to: number, v: number) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);\n};\n\n// http://codepen.io/osublake/pen/xGVVaN\nexport const blendColor = (from: Color | string, to: Color | string) => {\n  const fromColor = (typeof from === 'string') ? color.parse(from) : from;\n  const toColor = (typeof to === 'string') ? color.parse(to) : to;\n  let blended = { ...fromColor };\n\n  // Only use the sqrt blending function for rgba and hex\n  const blendFunc = (\n    (from as HSLA).hue !== undefined ||\n    typeof from === 'string' && hsla.test(from as string)\n  ) ? getValueFromProgress\n    : blend;\n\n  return (v: number) => {\n    blended = { ...blended };\n    for (const key in blended) {\n      if (key !== 'alpha' && blended.hasOwnProperty(key)) {\n        blended[key] = blendFunc(fromColor[key], toColor[key], v);\n      }\n    }\n\n    blended.alpha = getValueFromProgress(fromColor.alpha, toColor.alpha, v);\n\n    return blended;\n  };\n};\n\n/**\n * Clamp value between\n * Creates a function that will restrict a given value between `min` and `max`\n * @param  {number} min\n * @param  {number} max\n * @return {number}\n */\nexport const clamp = (min: number, max: number) => (v: number) => Math.min(Math.max(v, min), max);\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a: Function, b: Function) => (v: any) => b(a(v));\nexport const pipe = (...transformers: Function[]) => transformers.reduce(combineFunctions);\n\n/**\n * Conditionally apply a transformer using the provided function when `check` returns `true`\n */\nexport type Check = (v: any) => boolean;\nexport type Apply = (v: any) => any;\nexport const conditional = (check: Check, apply: Apply) => (v: any): any => check(v) ? apply(v) : v;\n\n/**\n * Interpolate from set of values to another\n */\nconst slowInterpolate = (input: number[], output: number[], rangeLength: number, rangeEasing: Easing[]) => {\n  const finalIndex = rangeLength - 1;\n\n  // If input runs highest -> lowest, reverse both arrays\n  if (input[0] > input[finalIndex]) {\n    input.reverse();\n    output.reverse();\n  }\n\n  return (v: number) => {\n    // If value outside minimum range, quickly return\n    if (v <= input[0]) {\n      return output[0];\n    }\n\n    // If value outside maximum range, quickly return\n    if (v >= input[finalIndex]) {\n      return output[finalIndex];\n    }\n\n    let i = 1;\n\n    // Find index of range start\n    for (; i < rangeLength; i++) {\n      if (input[i] > v || i === finalIndex) {\n        break;\n      }\n    }\n\n    const progressInRange = getProgressFromValue(input[i - 1], input[i], v);\n    const easedProgress = (rangeEasing) ? rangeEasing[i - 1](progressInRange) : progressInRange;\n    return getValueFromProgress(output[i - 1], output[i], easedProgress);\n  };\n};\n\nconst fastInterpolate = (minA: number, maxA: number, minB: number, maxB: number) => (v: number) =>\n  (((v - minA) * (maxB - minB)) / (maxA - minA)) + minB;\n\nexport const interpolate = (input: number[], output: number[], rangeEasing?: Easing[]) => {\n  const rangeLength = input.length;\n  return rangeLength !== 2\n    ? slowInterpolate(input, output, rangeLength, rangeEasing)\n    : fastInterpolate(input[0], input[1], output[0], output[1])\n};\n\nexport const generateStaticSpring = (alterDisplacement: Function = noop) => (constant: number, origin: number) => (v: number) => {\n  const displacement = origin - v;\n  const springModifiedDisplacement = - constant * (0 - alterDisplacement(Math.abs(displacement)));\n  return (displacement <= 0) ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n};\n\nexport const linearSpring = generateStaticSpring();\nexport const nonlinearSpring = generateStaticSpring(Math.sqrt);\n\nexport const wrap = (min: number, max: number) => (v: number) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nexport const smooth = (strength: number = 50) => {\n  let previousValue = 0;\n  let lastUpdated = 0;\n\n  return (v: number) => {\n    const currentFramestamp = currentFrameTime();\n    const timeDelta = (currentFramestamp !== lastUpdated) ? currentFramestamp - lastUpdated : 0;\n    const newValue = timeDelta ? calcSmoothing(v, previousValue, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nexport const snap = (points: number | number[]) => {\n  if (typeof points === 'number') {\n    return (v: number) => Math.round(v / points) * points;\n  } else {\n    let i = 0;\n    const numPoints = points.length;\n\n    return (v: number) => {\n      let lastDistance = Math.abs(points[0] - v);\n\n      for (i = 1; i < numPoints; i++) {\n        const point = points[i];\n        const distance = Math.abs(point - v);\n\n        if (distance === 0) return point;\n\n        if (distance > lastDistance) return points[i - 1];\n\n        if (i === numPoints - 1) return point;\n\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\n// TODO: Revist this and add direction\nexport const steps = (st: number, min = 0, max = 1) => (v: number) => {\n  const progress = getProgressFromValue(min, max, v);\n  return getValueFromProgress(min, max, stepProgress(st, progress));\n};\n\nexport const transformMap = (childTransformers: { [key: string]: Function }) => (v: any) => {\n  const output: { [key: string]: any } = { ...v };\n\n  for (const key in childTransformers) {\n    if (childTransformers.hasOwnProperty(key)) {\n      const childTransformer = childTransformers[key];\n      output[key] = childTransformer(v[key]);\n    }\n  }\n\n  return output;\n};\n"]}},"error":null,"hash":"da4a099a04039a2763edcae6a4b4dff9","cacheData":{"env":{}}}