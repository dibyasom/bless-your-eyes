{"id":"node_modules/popmotion/calc.js","dependencies":[{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/calc.js.map","includedInParent":true,"mtime":1525955812000},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/src/calc.ts","includedInParent":true,"mtime":1525607567000},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/package.json","includedInParent":true,"mtime":1611669448384},{"name":"/home/divyu/Documents/GitHub/bless-your-eyes/node_modules/popmotion/package.json","includedInParent":true,"mtime":1611669448356}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isNum = function (v) { return typeof v === 'number'; };\nexports.isPoint = function (point) {\n    return point.x !== undefined && point.y !== undefined;\n};\nexports.isPoint3D = function (point) {\n    return point.z !== undefined;\n};\nvar toDecimal = function (num, precision) {\n    if (precision === void 0) { precision = 2; }\n    precision = Math.pow(10, precision);\n    return Math.round(num * precision) / precision;\n};\nvar ZERO_POINT = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nvar distance1D = function (a, b) { return Math.abs(a - b); };\nexports.angle = function (a, b) {\n    if (b === void 0) { b = ZERO_POINT; }\n    return exports.radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n};\nexports.degreesToRadians = function (degrees) { return degrees * Math.PI / 180; };\nexports.dilate = function (a, b, dilation) { return a + ((b - a) * dilation); };\nexports.distance = function (a, b) {\n    if (b === void 0) { b = ZERO_POINT; }\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (exports.isPoint(a) && exports.isPoint(b)) {\n        var xDelta = distance1D(a.x, b.x);\n        var yDelta = distance1D(a.y, b.y);\n        var zDelta = (exports.isPoint3D(a) && exports.isPoint3D(b)) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt((Math.pow(xDelta, 2)) + (Math.pow(yDelta, 2)) + (Math.pow(zDelta, 2)));\n    }\n    return 0;\n};\nexports.getProgressFromValue = function (from, to, value) {\n    var toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nexports.getValueFromProgress = function (from, to, progress) {\n    return (-progress * from) + (progress * to) + from;\n};\nexports.pointFromAngleAndDistance = function (origin, angle, distance) {\n    angle = exports.degreesToRadians(angle);\n    return {\n        x: distance * Math.cos(angle) + origin.x,\n        y: distance * Math.sin(angle) + origin.y\n    };\n};\nexports.radiansToDegrees = function (radians) { return radians * 180 / Math.PI; };\nexports.smooth = function (newValue, oldValue, duration, smoothing) {\n    if (smoothing === void 0) { smoothing = 0; }\n    return toDecimal(oldValue + (duration * (newValue - oldValue) / Math.max(smoothing, duration)));\n};\nexports.speedPerFrame = function (xps, frameDuration) {\n    return (isNum(xps)) ? xps / (1000 / frameDuration) : 0;\n};\nexports.speedPerSecond = function (velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n};\nexports.stepProgress = function (steps, progress) {\n    var segment = 1 / (steps - 1);\n    var target = 1 - (1 / steps);\n    var progressOfTarget = Math.min(progress / target, 1);\n    return Math.floor(progressOfTarget / segment) * segment;\n};\n"},"sourceMaps":{"js":{"version":3,"file":"calc.js","sourceRoot":"","sources":["src/calc.ts"],"names":[],"mappings":"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","sourcesContent":["import { Point, Point2D, Point3D } from './input/pointer/types';\n\nconst isNum = (v: any): v is number => typeof v === 'number';\n\nexport const isPoint = (point: any): point is Point => {\n  return (point as Point).x !== undefined && (point as Point).y !== undefined;\n};\n\nexport const isPoint3D = (point: Point): point is Point3D => {\n  return (point as Point3D).z !== undefined;\n};\n\n/*\n  Convert number to x decimal places\n\n  @param [number]\n  @param [number]\n  @return [number]\n*/\nconst toDecimal = (num: number, precision: number = 2) => {\n  precision = 10 ** precision;\n  return Math.round(num * precision) / precision;\n};\n\nconst ZERO_POINT: Point = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nconst distance1D = (a: number, b: number) => Math.abs(a - b);\n\n/*\n  Angle between points\n\n  Translates the hypothetical line so that the 'from' coordinates\n  are at 0,0\n\n  @param [object]: X and Y coordinates of from point\n  @param [object]: X and Y coordinates of to point\n  @return [radian]: Angle between the two points in radians\n*/\nexport const angle = (a: Point, b: Point = ZERO_POINT) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\n/*\n  Convert degrees to radians\n\n  @param [number]: Value in degrees\n  @return [number]: Value in radians\n*/\nexport const degreesToRadians = (degrees: number) => degrees * Math.PI / 180;\n\n/*\n  Dilate\n\n  Change the progression between a and b according to dilation.\n\n  So dilation = 0.5 would change\n\n  a --------- b\n\n  to\n\n  a ---- b\n\n  @param [number]: Previous value\n  @param [number]: Current value\n  @param [number]: Dilate progress by x\n  @return [number]: Previous value plus the dilated difference\n*/\nexport const dilate = (a: number, b: number, dilation: number) => a + ((b - a) * dilation);\n\n/*\n  Distance\n\n  Returns the distance between two n dimensional points.\n\n  @param [object/number]: x and y or just x of point A\n  @param [object/number]: (optional): x and y or just x of point B\n  @return [number]: The distance between the two points\n*/\nexport const distance = (a: Point | number, b: Point | number = ZERO_POINT): number => {\n  // 1D dimensions\n  if (isNum(a) && isNum(b)) {\n    return distance1D(a, b);\n\n  // Multi-dimensional\n  } else if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    const zDelta = (isPoint3D(a) && isPoint3D(b)) ? distance1D(a.z, b.z) : 0;\n\n    return Math.sqrt((xDelta ** 2) + (yDelta ** 2) + (zDelta ** 2));\n  }\n\n  return 0;\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nexport const getProgressFromValue = (from: number, to: number, value: number) => {\n  const toFromDifference = to - from;\n\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n}\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (a number from 0-1)\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nexport const getValueFromProgress = (from: number, to: number, progress: number) =>\n  (- progress * from) + (progress * to) + from;\n\n/*\n  Point from angle and distance\n\n  @param [object]: 2D point of origin\n  @param [number]: Angle from origin\n  @param [number]: Distance from origin\n  @return [object]: Calculated 2D point\n*/\nexport const pointFromAngleAndDistance = (origin: Point2D, angle: number, distance: number) => {\n  angle = degreesToRadians(angle);\n\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\n/*\n  Convert radians to degrees\n\n  @param [number]: Value in radians\n  @return [number]: Value in degrees\n*/\nexport const radiansToDegrees = (radians: number) => radians * 180 / Math.PI;\n\n/*\n  Framerate-independent smoothing\n\n  @param [number]: New value\n  @param [number]: Old value\n  @param [number]: Frame duration\n  @param [number] (optional): Smoothing (0 is none)\n*/\nexport const smooth = (newValue: number, oldValue: number, duration: number, smoothing: number = 0) =>\n  toDecimal(oldValue + (duration * (newValue - oldValue) / Math.max(smoothing, duration)));\n\n/*\n  Convert x per second to per frame velocity based on fps\n\n  @param [number]: Unit per second\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerFrame = (xps: number, frameDuration: number) =>\n  (isNum(xps)) ? xps / (1000 / frameDuration) : 0;\n\n/*\n  Convert velocity into velicity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerSecond = (velocity: number, frameDuration: number) =>\n  frameDuration ? velocity * (1000 / frameDuration) : 0;\n\n/*\n  Create stepped version of 0-1 progress\n\n  @param [int]: Number of steps\n  @param [number]: Current value\n  @return [number]: Stepped value\n*/\nexport const stepProgress = (steps: number, progress: number) => {\n  const segment = 1 / (steps - 1);\n  const target = 1 - (1 / steps);\n  const progressOfTarget = Math.min(progress / target, 1);\n\n  return Math.floor(progressOfTarget / segment) * segment;\n};\n"]}},"error":null,"hash":"a98e250a63063691429870798045bf3d","cacheData":{"env":{}}}